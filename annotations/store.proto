syntax = "proto3";

package goten.annotations;

import "google/protobuf/descriptor.proto";

option go_package = "github.com/cloudwan/goten-sdk/annotations/store";
option java_multiple_files = true;
option java_outer_classname = "GotenProtoStore";
option java_package = "com.ntt.goten.annotations.store";

// Transaction options for generated middleware performing tx injection based on
// generated datastore If not specified in action option, autogenerated code
// will assign SNAPSHOT type.
message StoreHandleSpec {
  bool read_only = 1;

  Transaction transaction = 2;

  enum Transaction {
    NONE = 0;

    SNAPSHOT = 1;

    MANUAL = 2;
  }
}

// CacheSpec defines how instances of associated
// resource are cached by server. This is supported only
// for objects that are resources. If no spec is defined,
// goten store does not use cache for given resource.
message CacheSpec {
  // Disables caching resources by name
  bool disable_caching_by_name = 1;

  // List of all sets of query fields for which cache will
  // apply (if any one of them is present in query filter).
  repeated QueryFields queries = 2;

  // List of minimal scopes that must be satisfied by
  // reference or name fields that are present in field "queries".
  // If you dont specify patterns for some references or name field, then
  // goten will assume default QueryReferencePatterns using following rules:
  //
  // - references to foreign resources must be fully specified.
  //   For example, suppose there is resource "Group" which has parents
  //   (Projects, Organizations and NONE). Suppose we have another resource
  //   like RoleBinding that has reference to "Group" resource by field "group".
  //   Now we are defining CacheSpec for resource RoleBinding where one of the
  //   QueryFields has "group". If we dont specify QueryReferencePatterns for
  //   this field, following will be assumed by Goten:
  //   QueryReferencePatterns: { field_path: "group", patterns: [
  //     "groups/{group}", "projects/{project}/groups/{group}",
  //     "organizations/{organization}/groups/{group}"
  //   ] }
  //
  // - name fields must have fully specified parent.
  //   For example, suppose there is resource "Group" which has parents
  //   (Projects, Organizations and NONE).
  //   If we want to define CacheSpec for this resource and at least
  //   one QueryFields contains "name", then if we dont provide
  //   QueryReferencePatterns, then following will be assumed by Goten:
  //   QueryReferencePatterns: { field_path: "name", patterns: [
  //     "groups/-", "projects/{project}/groups/-",
  //     "organizations/{organization}/groups/-"
  //   ] }
  repeated QueryReferencePatterns query_reference_patterns = 3;

  // QueryFields defines list of fields in resource
  // that must be present in query filter in order for
  // query to be cached.
  // Example:
  // if QueryFields is { eq_field_paths: [ "name", "spec.group" ]
  // for given resource, then only queries that contain both "name" filter
  // condition (via Compare operator) and "spec.group" filter condition
  // (via Compare and IN operators) will be cached.
  message QueryFields {
    // List of field paths that must be present in the query filter
    // in order to be cached.
    // Supported filter types: Compare and IN (except IN does not work
    // for name field).
    repeated string eq_field_paths = 1;
  }

  // List of minimal patterns that must be satisfied
  // by given name or reference field (specified by field_path)
  // in query filter in order to satisfy relevant field
  // in each QueryFields where it is present.
  // Example:
  // - Suppose we resource which name is Device (parent of device is "Project")
  // - It has field spec.group (referencing resource Group with "Project" as
  // parent)
  // - QueryFields is { eq_field_paths: [ "name", "spec.group" ]
  // - QueryReferencePatterns are:
  //   { field_path: "name", patterns = ["projects/{project}/devices/-"]
  //   { field_path: "spec.group", patterns =
  //   ["projects/{project}/groups/{group}"]
  // In situation above, if server receives a query with filter:
  // name="projects/default/devices/-" AND
  // spec.group="projects/default/groups/-", then query will not be cached
  // because minimal filter for spec.group is no satisfied. If however
  // spec.group="projects/default/groups/default" then query will be cached. You
  // dont have to define all scopes - pattern like projects/-/groups/- already
  // includes projects/{project}/groups/{group} and projects/{project}/groups/-
  // and projects/-/groups/{group}. But you may want to add more patterns if
  // there is multiple ancestor paths.
  message QueryReferencePatterns {
    // Full path to name or reference field
    string field_path = 1;

    // List of minimal patterns that reference
    // or name field must satisfy. You can define
    // more patterns if resource has many ancestor paths.
    repeated string patterns = 2;
  }
}

// IndicesSpec defines list of store indices for given resource. This annotation
// can be used only for resources, otherwise its ignored. Resource without this
// spec may not have any indices apart from name field (unless adapter provides
// some default indices). Collection queries (like List) are not guaranteed to
// work unless for simple cases (no paging, no sorting, only simple
// equality-like filters). For more information about indices, check selected
// db adapter.
// Example:
//
// option (goten.store.indices) = {
//   composite: {
//     sorting_groups : [ {
//       name : "byName",
//       order_by : "name",
//       scopes : [
//         "projects/{project}/regions/{region}/zones/-/devices/-",
//         "projects/{project}/regions/{region}/zones/{zone}/devices/-"
//       ]
//     } ]
//     filters : [
//       {field_path : "status.system.serial_number"},
//     ]
//   }
//   single: [ {
//     field_path : "spec.enabled"
//   }, {
//     field_path : "spec.group",
//     reference_patterns : [ "projects/{project}/groups/{group}" ]
//   } ]
//};
//
// Above set will create following indices (last two are single fields):
// - filter (name.projectId, name.regionId) orderBy (name.zoneId ASC, name.deviceId ASC)
// - filter (name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId ASC)
// - filter (name.projectId, name.regionId) orderBy (name.zoneId DESC, name.deviceId DESC)
// - filter (name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId DESC)
// - filter (status.system.serial_number, name.projectId, name.regionId) orderBy (name.zoneId ASC, name.deviceId ASC)
// - filter (status.system.serial_number, name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId ASC)
// - filter (status.system.serial_number, name.projectId, name.regionId) orderBy (name.zoneId DESC, name.deviceId DESC)
// - filter (status.system.serial_number, name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId DESC)
// - filter by spec.enabled
// - filter by spec.group
//
// Explanation for composite indices:
// Each sorting group is matched with combinations of all filters - the more filters, the more indices for given group.
// If there are 3 filters, then there is a power(2,3) of possible combinations = 8. Then that number is multiplied
// by number of scopes and sorting directions (always 2). In this example, there is one filter (pow(2, 1) = 2), 2
// scopes, 2 sorting directions. Therefore number of indices for sorting group byName is: pow(2, 1) * 2 * 2 = 8.
// System then guarantees that devices can be listed:
// * With or without zoneId (but project and region must be specified in parent field)
// * With sorting/pagination using name field.
// * With optional filter on serial number.
//
// It is important to note that inequality filters (!=, >, <, >=, <=, NOT IN) may (likely)
// require specification using SORTING group! In other words, if there is a field like "start_time" in which
// we need to filter using inequality filters, we must create sorting group with "start_time" as "order_by" field.
message IndicesSpec {
  // Composite indices specification.
  Composite composite = 1;

  // List of single field indices.
  repeated SingleField single = 2;

  // SortingGroup defines single field according to which sorting (and inequality filters) will be possible.
  // It is being matched with optional/required filters.
  // If sorting field is DIFFERENT than name, then it is important to note that system will automatically
  // assume sorting by name as secondary! For example, if we want to sort by "creation_time", then system
  // will make following sorting indices:
  // - by creation_time ASC, name ASC
  // - by creation_time DESC, name DESC
  // Adding name as secondary field is implicit and it is done to ensure uniqueness.
  message SortingGroup {
    // Name of the group. It can be used to restrict filters that match the group.
    string name = 1;

    // Field path used for ordering. It is important to note that this also enables
    // inequality filters.
    string order_by = 2;

    // List of NAME scopes for this group. It is worth to note that even if order_by points to different
    // field than name, scopes are still important, because name field is then used as secondary order field.
    // If scopes are not provided, system assumes all fully specified scopes except final resource ID. For example,
    // if resource "Device" has one name pattern (projects/{project}/regions/{region}/zones/{zone}/devices/{device},
    // then scopes is equal to: [ "projects/{project}/regions/{region}/zones/{zone}/devices/-" ].
    // If there were more name patterns, one scope would be for each. Note that this will disable indices across
    // not only projects, but regions and zones too.
    repeated string scopes = 3;

    // Maximum number of filter fields that can be matched for this group. Setting
    // this field limits number of created indices, because those containing more
    // fields than indicated are not generated. If this value is left uninitialized (0),
    // then no maximum is applied.
    int32 max_filter_fields = 4;

    // List of DB adapters that should be used for this sorting group. If not specified, all DB adapters
    repeated string db_adapters = 5;
  }

  // Filter instructs to include specific field path in selected composite indices, according to matched
  // sorting groups.
  message Filter {
    // Field path of the indexed field.
    string field_path = 1;

    // Whether field is required in each index. If true, it will limit number of generated indices,
    // because we do not need to generate composite indices without it. It will not count into limit
    // imposed by max_filter_fields.
    bool required = 2;

    // List of sorting group names in which this filter should be present. If not specified it will be
    // matched with ALL sorting groups.
    repeated string restricted_sorting_groups = 3;

    // If field path is a name/reference type, then this field defines list of patterns (scopes) that
    // are supported. If not present, only fully specified are supported.
    repeated string reference_patterns = 4;

    // List of DB adapters that should be used for this filter. If not specified, all DB adapters
    repeated string db_adapters = 5;
  }

  // SingleField describes index for single filtering field only.
  message SingleField {
    // Field path that will be indexed.
    string field_path = 1;

    // Whether this index is wildcard - all subfields are indexed. Supported for mongo only,
    // must be mentioned in db_adapters.
    bool is_wildcard = 2;

    // If field path is a name/reference type, then this field defines list of patterns (scopes) that
    // are supported. If not present, only fully specified are supported.
    repeated string reference_patterns = 3;

    // List of DB adapters that should be used for this index. If not specified, all DB adapters
    repeated string db_adapters = 4;
  }

  // Composite binds sorting groups with filters to create composite indices.
  message Composite {
    // List of sorting groups in resource.
    repeated SortingGroup sorting_groups = 1;

    // List of filters to match with sorting groups.
    repeated Filter filters = 2;
  }
}

extend google.protobuf.MessageOptions {
  CacheSpec cache = 72011;

  IndicesSpec indices = 69110;
}

extend google.protobuf.MethodOptions {
  StoreHandleSpec tx = 69060;
}
