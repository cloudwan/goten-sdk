// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.1
// 	protoc        v4.25.2
// source: goten/annotations/store.proto

package store

import (
	_ "github.com/cloudwan/goten-sdk/annotations/goten"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StoreHandleSpec_Transaction int32

const (
	StoreHandleSpec_NONE     StoreHandleSpec_Transaction = 0
	StoreHandleSpec_SNAPSHOT StoreHandleSpec_Transaction = 1
	StoreHandleSpec_MANUAL   StoreHandleSpec_Transaction = 2
)

// Enum value maps for StoreHandleSpec_Transaction.
var (
	StoreHandleSpec_Transaction_name = map[int32]string{
		0: "NONE",
		1: "SNAPSHOT",
		2: "MANUAL",
	}
	StoreHandleSpec_Transaction_value = map[string]int32{
		"NONE":     0,
		"SNAPSHOT": 1,
		"MANUAL":   2,
	}
)

func (x StoreHandleSpec_Transaction) Enum() *StoreHandleSpec_Transaction {
	p := new(StoreHandleSpec_Transaction)
	*p = x
	return p
}

func (x StoreHandleSpec_Transaction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StoreHandleSpec_Transaction) Descriptor() protoreflect.EnumDescriptor {
	return file_goten_annotations_store_proto_enumTypes[0].Descriptor()
}

func (StoreHandleSpec_Transaction) Type() protoreflect.EnumType {
	return &file_goten_annotations_store_proto_enumTypes[0]
}

func (x StoreHandleSpec_Transaction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StoreHandleSpec_Transaction.Descriptor instead.
func (StoreHandleSpec_Transaction) EnumDescriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{0, 0}
}

// Transaction options for generated middleware performing tx injection based on
// generated datastore If not specified in action option, autogenerated code
// will assign SNAPSHOT type.
type StoreHandleSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ReadOnly    bool                        `protobuf:"varint,1,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Transaction StoreHandleSpec_Transaction `protobuf:"varint,2,opt,name=transaction,proto3,enum=goten.annotations.StoreHandleSpec_Transaction" json:"transaction,omitempty"`
}

func (x *StoreHandleSpec) Reset() {
	*x = StoreHandleSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StoreHandleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoreHandleSpec) ProtoMessage() {}

func (x *StoreHandleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoreHandleSpec.ProtoReflect.Descriptor instead.
func (*StoreHandleSpec) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{0}
}

func (x *StoreHandleSpec) GetReadOnly() bool {
	if x != nil {
		return x.ReadOnly
	}
	return false
}

func (x *StoreHandleSpec) GetTransaction() StoreHandleSpec_Transaction {
	if x != nil {
		return x.Transaction
	}
	return StoreHandleSpec_NONE
}

// CacheSpec defines how instances of associated
// resource are cached by server. This is supported only
// for objects that are resources. If no spec is defined,
// goten store does not use cache for given resource.
type CacheSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Disables caching resources by name
	DisableCachingByName bool `protobuf:"varint,1,opt,name=disable_caching_by_name,json=disableCachingByName,proto3" json:"disable_caching_by_name,omitempty"`
	// List of all sets of query fields for which cache will
	// apply (if any one of them is present in query filter).
	Queries []*CacheSpec_QueryFields `protobuf:"bytes,2,rep,name=queries,proto3" json:"queries,omitempty"`
	// List of minimal scopes that must be satisfied by
	// reference or name fields that are present in field "queries".
	// If you dont specify patterns for some references or name field, then
	// goten will assume default QueryReferencePatterns using following rules:
	//
	//   - references to foreign resources must be fully specified.
	//     For example, suppose there is resource "Group" which has parents
	//     (Projects, Organizations and NONE). Suppose we have another resource
	//     like RoleBinding that has reference to "Group" resource by field "group".
	//     Now we are defining CacheSpec for resource RoleBinding where one of the
	//     QueryFields has "group". If we dont specify QueryReferencePatterns for
	//     this field, following will be assumed by Goten:
	//     QueryReferencePatterns: { field_path: "group", patterns: [
	//     "groups/{group}", "projects/{project}/groups/{group}",
	//     "organizations/{organization}/groups/{group}"
	//     ] }
	//
	//   - name fields must have fully specified parent.
	//     For example, suppose there is resource "Group" which has parents
	//     (Projects, Organizations and NONE).
	//     If we want to define CacheSpec for this resource and at least
	//     one QueryFields contains "name", then if we dont provide
	//     QueryReferencePatterns, then following will be assumed by Goten:
	//     QueryReferencePatterns: { field_path: "name", patterns: [
	//     "groups/-", "projects/{project}/groups/-",
	//     "organizations/{organization}/groups/-"
	//     ] }
	QueryReferencePatterns []*CacheSpec_QueryReferencePatterns `protobuf:"bytes,3,rep,name=query_reference_patterns,json=queryReferencePatterns,proto3" json:"query_reference_patterns,omitempty"`
}

func (x *CacheSpec) Reset() {
	*x = CacheSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CacheSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CacheSpec) ProtoMessage() {}

func (x *CacheSpec) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CacheSpec.ProtoReflect.Descriptor instead.
func (*CacheSpec) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{1}
}

func (x *CacheSpec) GetDisableCachingByName() bool {
	if x != nil {
		return x.DisableCachingByName
	}
	return false
}

func (x *CacheSpec) GetQueries() []*CacheSpec_QueryFields {
	if x != nil {
		return x.Queries
	}
	return nil
}

func (x *CacheSpec) GetQueryReferencePatterns() []*CacheSpec_QueryReferencePatterns {
	if x != nil {
		return x.QueryReferencePatterns
	}
	return nil
}

// IndicesSpec defines list of store indices for given resource. This annotation
// can be used only for resources, otherwise its ignored. Resource without this
// spec may not have any indices apart from name field (unless adapter provides
// some default indices). Collection queries (like List) are not guaranteed to
// work unless for simple cases (no paging, no sorting, only simple
// equality-like filters). For more information about indices, check selected
// db adapter.
// Example:
//
//	option (goten.store.indices) = {
//	  composite: {
//	    sorting_groups : [ {
//	      name : "byName",
//	      order_by : "name",
//	      scopes : [
//	        "projects/{project}/regions/{region}/zones/-/devices/-",
//	        "projects/{project}/regions/{region}/zones/{zone}/devices/-"
//	      ]
//	    } ]
//	    filters : [
//	      {field_path : "status.system.serial_number"},
//	    ]
//	  }
//	  single: [ {
//	    field_path : "spec.enabled"
//	  }, {
//	    field_path : "spec.group",
//	    reference_patterns : [ "projects/{project}/groups/{group}" ]
//	  } ]
//	};
//
// Above set will create following indices (last two are single fields):
// - filter (name.projectId, name.regionId) orderBy (name.zoneId ASC, name.deviceId ASC)
// - filter (name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId ASC)
// - filter (name.projectId, name.regionId) orderBy (name.zoneId DESC, name.deviceId DESC)
// - filter (name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId DESC)
// - filter (status.system.serial_number, name.projectId, name.regionId) orderBy (name.zoneId ASC, name.deviceId ASC)
// - filter (status.system.serial_number, name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId ASC)
// - filter (status.system.serial_number, name.projectId, name.regionId) orderBy (name.zoneId DESC, name.deviceId DESC)
// - filter (status.system.serial_number, name.projectId, name.regionId, name.zoneId) orderBy (name.deviceId DESC)
// - filter by spec.enabled
// - filter by spec.group
//
// Explanation for composite indices:
// Each sorting group is matched with combinations of all filters - the more filters, the more indices for given group.
// If there are 3 filters, then there is a power(2,3) of possible combinations = 8. Then that number is multiplied
// by number of scopes and sorting directions (always 2). In this example, there is one filter (pow(2, 1) = 2), 2
// scopes, 2 sorting directions. Therefore number of indices for sorting group byName is: pow(2, 1) * 2 * 2 = 8.
// System then guarantees that devices can be listed:
// * With or without zoneId (but project and region must be specified in parent field)
// * With sorting/pagination using name field.
// * With optional filter on serial number.
//
// It is important to note that inequality filters (!=, >, <, >=, <=, NOT IN) may (likely)
// require specification using SORTING group! In other words, if there is a field like "start_time" in which
// we need to filter using inequality filters, we must create sorting group with "start_time" as "order_by" field.
type IndicesSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Composite indices specification.
	Composite *IndicesSpec_Composite `protobuf:"bytes,1,opt,name=composite,proto3" json:"composite,omitempty"`
	// List of single field indices.
	Single []*IndicesSpec_SingleField `protobuf:"bytes,2,rep,name=single,proto3" json:"single,omitempty"`
}

func (x *IndicesSpec) Reset() {
	*x = IndicesSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IndicesSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndicesSpec) ProtoMessage() {}

func (x *IndicesSpec) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndicesSpec.ProtoReflect.Descriptor instead.
func (*IndicesSpec) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{2}
}

func (x *IndicesSpec) GetComposite() *IndicesSpec_Composite {
	if x != nil {
		return x.Composite
	}
	return nil
}

func (x *IndicesSpec) GetSingle() []*IndicesSpec_SingleField {
	if x != nil {
		return x.Single
	}
	return nil
}

// QueryFields defines list of fields in resource
// that must be present in query filter in order for
// query to be cached.
// Example:
// if QueryFields is { eq_field_paths: [ "name", "spec.group" ]
// for given resource, then only queries that contain both "name" filter
// condition (via Compare operator) and "spec.group" filter condition
// (via Compare and IN operators) will be cached.
type CacheSpec_QueryFields struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of field paths that must be present in the query filter
	// in order to be cached.
	// Supported filter types: Compare and IN (except IN does not work
	// for name field).
	EqFieldPaths []string `protobuf:"bytes,1,rep,name=eq_field_paths,json=eqFieldPaths,proto3" json:"eq_field_paths,omitempty"`
}

func (x *CacheSpec_QueryFields) Reset() {
	*x = CacheSpec_QueryFields{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CacheSpec_QueryFields) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CacheSpec_QueryFields) ProtoMessage() {}

func (x *CacheSpec_QueryFields) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CacheSpec_QueryFields.ProtoReflect.Descriptor instead.
func (*CacheSpec_QueryFields) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{1, 0}
}

func (x *CacheSpec_QueryFields) GetEqFieldPaths() []string {
	if x != nil {
		return x.EqFieldPaths
	}
	return nil
}

// List of minimal patterns that must be satisfied
// by given name or reference field (specified by field_path)
// in query filter in order to satisfy relevant field
// in each QueryFields where it is present.
// Example:
// - Suppose we resource which name is Device (parent of device is "Project")
// - It has field spec.group (referencing resource Group with "Project" as
// parent)
//   - QueryFields is { eq_field_paths: [ "name", "spec.group" ]
//   - QueryReferencePatterns are:
//     { field_path: "name", patterns = ["projects/{project}/devices/-"]
//     { field_path: "spec.group", patterns =
//     ["projects/{project}/groups/{group}"]
//
// In situation above, if server receives a query with filter:
// name="projects/default/devices/-" AND
// spec.group="projects/default/groups/-", then query will not be cached
// because minimal filter for spec.group is no satisfied. If however
// spec.group="projects/default/groups/default" then query will be cached. You
// dont have to define all scopes - pattern like projects/-/groups/- already
// includes projects/{project}/groups/{group} and projects/{project}/groups/-
// and projects/-/groups/{group}. But you may want to add more patterns if
// there is multiple ancestor paths.
type CacheSpec_QueryReferencePatterns struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Full path to name or reference field
	FieldPath string `protobuf:"bytes,1,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// List of minimal patterns that reference
	// or name field must satisfy. You can define
	// more patterns if resource has many ancestor paths.
	Patterns []string `protobuf:"bytes,2,rep,name=patterns,proto3" json:"patterns,omitempty"`
}

func (x *CacheSpec_QueryReferencePatterns) Reset() {
	*x = CacheSpec_QueryReferencePatterns{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CacheSpec_QueryReferencePatterns) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CacheSpec_QueryReferencePatterns) ProtoMessage() {}

func (x *CacheSpec_QueryReferencePatterns) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CacheSpec_QueryReferencePatterns.ProtoReflect.Descriptor instead.
func (*CacheSpec_QueryReferencePatterns) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{1, 1}
}

func (x *CacheSpec_QueryReferencePatterns) GetFieldPath() string {
	if x != nil {
		return x.FieldPath
	}
	return ""
}

func (x *CacheSpec_QueryReferencePatterns) GetPatterns() []string {
	if x != nil {
		return x.Patterns
	}
	return nil
}

// SortingGroup defines single field according to which sorting (and inequality filters) will be possible.
// It is being matched with optional/required filters.
// If sorting field is DIFFERENT than name, then it is important to note that system will automatically
// assume sorting by name as secondary! For example, if we want to sort by "creation_time", then system
// will make following sorting indices:
// - by creation_time ASC, name ASC
// - by creation_time DESC, name DESC
// Adding name as secondary field is implicit and it is done to ensure uniqueness.
type IndicesSpec_SortingGroup struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name of the group. It can be used to restrict filters that match the group.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Field path used for ordering. It is important to note that this also enables
	// inequality filters.
	OrderBy string `protobuf:"bytes,2,opt,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// List of NAME scopes for this group. It is worth to note that even if order_by points to different
	// field than name, scopes are still important, because name field is then used as secondary order field.
	// If scopes are not provided, system assumes all fully specified scopes except final resource ID. For example,
	// if resource "Device" has one name pattern (projects/{project}/regions/{region}/zones/{zone}/devices/{device},
	// then scopes is equal to: [ "projects/{project}/regions/{region}/zones/{zone}/devices/-" ].
	// If there were more name patterns, one scope would be for each. Note that this will disable indices across
	// not only projects, but regions and zones too.
	Scopes []string `protobuf:"bytes,3,rep,name=scopes,proto3" json:"scopes,omitempty"`
	// Maximum number of filter fields that can be matched for this group. Setting
	// this field limits number of created indices, because those containing more
	// fields than indicated are not generated. If this value is left uninitialized (0),
	// then no maximum is applied.
	MaxFilterFields int32 `protobuf:"varint,4,opt,name=max_filter_fields,json=maxFilterFields,proto3" json:"max_filter_fields,omitempty"`
	// List of DB adapters that should be used for this sorting group. If not specified, all DB adapters
	DbAdapters []string `protobuf:"bytes,5,rep,name=db_adapters,json=dbAdapters,proto3" json:"db_adapters,omitempty"`
}

func (x *IndicesSpec_SortingGroup) Reset() {
	*x = IndicesSpec_SortingGroup{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IndicesSpec_SortingGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndicesSpec_SortingGroup) ProtoMessage() {}

func (x *IndicesSpec_SortingGroup) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndicesSpec_SortingGroup.ProtoReflect.Descriptor instead.
func (*IndicesSpec_SortingGroup) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{2, 0}
}

func (x *IndicesSpec_SortingGroup) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IndicesSpec_SortingGroup) GetOrderBy() string {
	if x != nil {
		return x.OrderBy
	}
	return ""
}

func (x *IndicesSpec_SortingGroup) GetScopes() []string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

func (x *IndicesSpec_SortingGroup) GetMaxFilterFields() int32 {
	if x != nil {
		return x.MaxFilterFields
	}
	return 0
}

func (x *IndicesSpec_SortingGroup) GetDbAdapters() []string {
	if x != nil {
		return x.DbAdapters
	}
	return nil
}

// Filter instructs to include specific field path in selected composite indices, according to matched
// sorting groups.
type IndicesSpec_Filter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Field path of the indexed field.
	FieldPath string `protobuf:"bytes,1,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// Whether field is required in each index. If true, it will limit number of generated indices,
	// because we do not need to generate composite indices without it. It will not count into limit
	// imposed by max_filter_fields.
	Required bool `protobuf:"varint,2,opt,name=required,proto3" json:"required,omitempty"`
	// List of sorting group names in which this filter should be present. If not specified it will be
	// matched with ALL sorting groups.
	RestrictedSortingGroups []string `protobuf:"bytes,3,rep,name=restricted_sorting_groups,json=restrictedSortingGroups,proto3" json:"restricted_sorting_groups,omitempty"`
	// If field path is a name/reference type, then this field defines list of patterns (scopes) that
	// are supported. If not present, only fully specified are supported.
	ReferencePatterns []string `protobuf:"bytes,4,rep,name=reference_patterns,json=referencePatterns,proto3" json:"reference_patterns,omitempty"`
	// List of DB adapters that should be used for this filter. If not specified, all DB adapters
	DbAdapters []string `protobuf:"bytes,5,rep,name=db_adapters,json=dbAdapters,proto3" json:"db_adapters,omitempty"`
}

func (x *IndicesSpec_Filter) Reset() {
	*x = IndicesSpec_Filter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IndicesSpec_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndicesSpec_Filter) ProtoMessage() {}

func (x *IndicesSpec_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndicesSpec_Filter.ProtoReflect.Descriptor instead.
func (*IndicesSpec_Filter) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{2, 1}
}

func (x *IndicesSpec_Filter) GetFieldPath() string {
	if x != nil {
		return x.FieldPath
	}
	return ""
}

func (x *IndicesSpec_Filter) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *IndicesSpec_Filter) GetRestrictedSortingGroups() []string {
	if x != nil {
		return x.RestrictedSortingGroups
	}
	return nil
}

func (x *IndicesSpec_Filter) GetReferencePatterns() []string {
	if x != nil {
		return x.ReferencePatterns
	}
	return nil
}

func (x *IndicesSpec_Filter) GetDbAdapters() []string {
	if x != nil {
		return x.DbAdapters
	}
	return nil
}

// SingleField describes index for single filtering field only.
type IndicesSpec_SingleField struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Field path that will be indexed.
	FieldPath string `protobuf:"bytes,1,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// Whether this index is wildcard - all subfields are indexed. Supported for mongo only,
	// must be mentioned in db_adapters.
	IsWildcard bool `protobuf:"varint,2,opt,name=is_wildcard,json=isWildcard,proto3" json:"is_wildcard,omitempty"`
	// If field path is a name/reference type, then this field defines list of patterns (scopes) that
	// are supported. If not present, only fully specified are supported.
	ReferencePatterns []string `protobuf:"bytes,3,rep,name=reference_patterns,json=referencePatterns,proto3" json:"reference_patterns,omitempty"`
	// List of DB adapters that should be used for this index. If not specified, all DB adapters
	DbAdapters []string `protobuf:"bytes,4,rep,name=db_adapters,json=dbAdapters,proto3" json:"db_adapters,omitempty"`
}

func (x *IndicesSpec_SingleField) Reset() {
	*x = IndicesSpec_SingleField{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IndicesSpec_SingleField) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndicesSpec_SingleField) ProtoMessage() {}

func (x *IndicesSpec_SingleField) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndicesSpec_SingleField.ProtoReflect.Descriptor instead.
func (*IndicesSpec_SingleField) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{2, 2}
}

func (x *IndicesSpec_SingleField) GetFieldPath() string {
	if x != nil {
		return x.FieldPath
	}
	return ""
}

func (x *IndicesSpec_SingleField) GetIsWildcard() bool {
	if x != nil {
		return x.IsWildcard
	}
	return false
}

func (x *IndicesSpec_SingleField) GetReferencePatterns() []string {
	if x != nil {
		return x.ReferencePatterns
	}
	return nil
}

func (x *IndicesSpec_SingleField) GetDbAdapters() []string {
	if x != nil {
		return x.DbAdapters
	}
	return nil
}

// Composite binds sorting groups with filters to create composite indices.
type IndicesSpec_Composite struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of sorting groups in resource.
	SortingGroups []*IndicesSpec_SortingGroup `protobuf:"bytes,1,rep,name=sorting_groups,json=sortingGroups,proto3" json:"sorting_groups,omitempty"`
	// List of filters to match with sorting groups.
	Filters []*IndicesSpec_Filter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
}

func (x *IndicesSpec_Composite) Reset() {
	*x = IndicesSpec_Composite{}
	if protoimpl.UnsafeEnabled {
		mi := &file_goten_annotations_store_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IndicesSpec_Composite) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndicesSpec_Composite) ProtoMessage() {}

func (x *IndicesSpec_Composite) ProtoReflect() protoreflect.Message {
	mi := &file_goten_annotations_store_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndicesSpec_Composite.ProtoReflect.Descriptor instead.
func (*IndicesSpec_Composite) Descriptor() ([]byte, []int) {
	return file_goten_annotations_store_proto_rawDescGZIP(), []int{2, 3}
}

func (x *IndicesSpec_Composite) GetSortingGroups() []*IndicesSpec_SortingGroup {
	if x != nil {
		return x.SortingGroups
	}
	return nil
}

func (x *IndicesSpec_Composite) GetFilters() []*IndicesSpec_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

var file_goten_annotations_store_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.MessageOptions)(nil),
		ExtensionType: (*CacheSpec)(nil),
		Field:         72011,
		Name:          "goten.annotations.cache",
		Tag:           "bytes,72011,opt,name=cache",
		Filename:      "goten/annotations/store.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MessageOptions)(nil),
		ExtensionType: (*IndicesSpec)(nil),
		Field:         69110,
		Name:          "goten.annotations.indices",
		Tag:           "bytes,69110,opt,name=indices",
		Filename:      "goten/annotations/store.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*StoreHandleSpec)(nil),
		Field:         69060,
		Name:          "goten.annotations.tx",
		Tag:           "bytes,69060,opt,name=tx",
		Filename:      "goten/annotations/store.proto",
	},
}

// Extension fields to descriptorpb.MessageOptions.
var (
	// optional goten.annotations.CacheSpec cache = 72011;
	E_Cache = &file_goten_annotations_store_proto_extTypes[0]
	// optional goten.annotations.IndicesSpec indices = 69110;
	E_Indices = &file_goten_annotations_store_proto_extTypes[1]
)

// Extension fields to descriptorpb.MethodOptions.
var (
	// optional goten.annotations.StoreHandleSpec tx = 69060;
	E_Tx = &file_goten_annotations_store_proto_extTypes[2]
)

var File_goten_annotations_store_proto protoreflect.FileDescriptor

var file_goten_annotations_store_proto_rawDesc = []byte{
	0x0a, 0x1d, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x2f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x11, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2f, 0x61, 0x6e, 0x6e, 0x6f,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x48, 0x61, 0x6e,
	0x64, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f,
	0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64,
	0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x50, 0x0a, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x67, 0x6f, 0x74, 0x65,
	0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x74,
	0x6f, 0x72, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73,
	0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x31, 0x0a, 0x0b, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12,
	0x0c, 0x0a, 0x08, 0x53, 0x4e, 0x41, 0x50, 0x53, 0x48, 0x4f, 0x54, 0x10, 0x01, 0x12, 0x0a, 0x0a,
	0x06, 0x4d, 0x41, 0x4e, 0x55, 0x41, 0x4c, 0x10, 0x02, 0x22, 0xff, 0x02, 0x0a, 0x09, 0x43, 0x61,
	0x63, 0x68, 0x65, 0x53, 0x70, 0x65, 0x63, 0x12, 0x35, 0x0a, 0x17, 0x64, 0x69, 0x73, 0x61, 0x62,
	0x6c, 0x65, 0x5f, 0x63, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x79, 0x5f, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c,
	0x65, 0x43, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x42,
	0x0a, 0x07, 0x71, 0x75, 0x65, 0x72, 0x69, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x28, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x52, 0x07, 0x71, 0x75, 0x65, 0x72, 0x69,
	0x65, 0x73, 0x12, 0x6d, 0x0a, 0x18, 0x71, 0x75, 0x65, 0x72, 0x79, 0x5f, 0x72, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x18, 0x03,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x70,
	0x65, 0x63, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63,
	0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x52, 0x16, 0x71, 0x75, 0x65, 0x72, 0x79,
	0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
	0x73, 0x1a, 0x33, 0x0a, 0x0b, 0x51, 0x75, 0x65, 0x72, 0x79, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73,
	0x12, 0x24, 0x0a, 0x0e, 0x65, 0x71, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x70, 0x61, 0x74,
	0x68, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x71, 0x46, 0x69, 0x65, 0x6c,
	0x64, 0x50, 0x61, 0x74, 0x68, 0x73, 0x1a, 0x53, 0x0a, 0x16, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52,
	0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73,
	0x12, 0x1d, 0x0a, 0x0a, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x61, 0x74, 0x68, 0x12,
	0x1a, 0x0a, 0x08, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x08, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x22, 0xd3, 0x06, 0x0a, 0x0b,
	0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x12, 0x46, 0x0a, 0x09, 0x63,
	0x6f, 0x6d, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28,
	0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x43,
	0x6f, 0x6d, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x65, 0x52, 0x09, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x65, 0x12, 0x42, 0x0a, 0x06, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x53,
	0x70, 0x65, 0x63, 0x2e, 0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x52,
	0x06, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x1a, 0xa2, 0x01, 0x0a, 0x0c, 0x53, 0x6f, 0x72, 0x74,
	0x69, 0x6e, 0x67, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x19, 0x0a, 0x08,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x42, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x63, 0x6f, 0x70, 0x65,
	0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x12,
	0x2a, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x5f, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x66, 0x69,
	0x65, 0x6c, 0x64, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x46,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x64,
	0x62, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x0a, 0x64, 0x62, 0x41, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x1a, 0xcf, 0x01, 0x0a,
	0x06, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x66, 0x69, 0x65, 0x6c, 0x64,
	0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x66, 0x69, 0x65,
	0x6c, 0x64, 0x50, 0x61, 0x74, 0x68, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
	0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
	0x65, 0x64, 0x12, 0x3a, 0x0a, 0x19, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64,
	0x5f, 0x73, 0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x17, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65,
	0x64, 0x53, 0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x12, 0x2d,
	0x0a, 0x12, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x74,
	0x65, 0x72, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x72, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x12, 0x1f, 0x0a,
	0x0b, 0x64, 0x62, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x0a, 0x64, 0x62, 0x41, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x9d,
	0x01, 0x0a, 0x0b, 0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x1d,
	0x0a, 0x0a, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x09, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x61, 0x74, 0x68, 0x12, 0x1f, 0x0a,
	0x0b, 0x69, 0x73, 0x5f, 0x77, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x12, 0x2d,
	0x0a, 0x12, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x74,
	0x65, 0x72, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x72, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x12, 0x1f, 0x0a,
	0x0b, 0x64, 0x62, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x0a, 0x64, 0x62, 0x41, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x1a, 0xa0,
	0x01, 0x0a, 0x09, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x65, 0x12, 0x52, 0x0a, 0x0e,
	0x73, 0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73,
	0x53, 0x70, 0x65, 0x63, 0x2e, 0x53, 0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x47, 0x72, 0x6f, 0x75,
	0x70, 0x52, 0x0d, 0x73, 0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73,
	0x12, 0x3f, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x53, 0x70, 0x65,
	0x63, 0x2e, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72,
	0x73, 0x3a, 0x55, 0x0a, 0x05, 0x63, 0x61, 0x63, 0x68, 0x65, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xcb, 0xb2, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x70, 0x65,
	0x63, 0x52, 0x05, 0x63, 0x61, 0x63, 0x68, 0x65, 0x3a, 0x5b, 0x0a, 0x07, 0x69, 0x6e, 0x64, 0x69,
	0x63, 0x65, 0x73, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x18, 0xf6, 0x9b, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x67,
	0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x2e, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x52, 0x07, 0x69, 0x6e,
	0x64, 0x69, 0x63, 0x65, 0x73, 0x3a, 0x54, 0x0a, 0x02, 0x74, 0x78, 0x12, 0x1e, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65,
	0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xc4, 0x9b, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e, 0x6f,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x48, 0x61, 0x6e,
	0x64, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x02, 0x74, 0x78, 0x42, 0x61, 0x0a, 0x1f, 0x63,
	0x6f, 0x6d, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x42, 0x0f,
	0x47, 0x6f, 0x74, 0x65, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x50,
	0x01, 0x5a, 0x2b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x77, 0x61, 0x6e, 0x2f, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2f, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_goten_annotations_store_proto_rawDescOnce sync.Once
	file_goten_annotations_store_proto_rawDescData = file_goten_annotations_store_proto_rawDesc
)

func file_goten_annotations_store_proto_rawDescGZIP() []byte {
	file_goten_annotations_store_proto_rawDescOnce.Do(func() {
		file_goten_annotations_store_proto_rawDescData = protoimpl.X.CompressGZIP(file_goten_annotations_store_proto_rawDescData)
	})
	return file_goten_annotations_store_proto_rawDescData
}

var file_goten_annotations_store_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_goten_annotations_store_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_goten_annotations_store_proto_goTypes = []interface{}{
	(StoreHandleSpec_Transaction)(0),         // 0: goten.annotations.StoreHandleSpec.Transaction
	(*StoreHandleSpec)(nil),                  // 1: goten.annotations.StoreHandleSpec
	(*CacheSpec)(nil),                        // 2: goten.annotations.CacheSpec
	(*IndicesSpec)(nil),                      // 3: goten.annotations.IndicesSpec
	(*CacheSpec_QueryFields)(nil),            // 4: goten.annotations.CacheSpec.QueryFields
	(*CacheSpec_QueryReferencePatterns)(nil), // 5: goten.annotations.CacheSpec.QueryReferencePatterns
	(*IndicesSpec_SortingGroup)(nil),         // 6: goten.annotations.IndicesSpec.SortingGroup
	(*IndicesSpec_Filter)(nil),               // 7: goten.annotations.IndicesSpec.Filter
	(*IndicesSpec_SingleField)(nil),          // 8: goten.annotations.IndicesSpec.SingleField
	(*IndicesSpec_Composite)(nil),            // 9: goten.annotations.IndicesSpec.Composite
	(*descriptorpb.MessageOptions)(nil),      // 10: google.protobuf.MessageOptions
	(*descriptorpb.MethodOptions)(nil),       // 11: google.protobuf.MethodOptions
}
var file_goten_annotations_store_proto_depIdxs = []int32{
	0,  // 0: goten.annotations.StoreHandleSpec.transaction:type_name -> goten.annotations.StoreHandleSpec.Transaction
	4,  // 1: goten.annotations.CacheSpec.queries:type_name -> goten.annotations.CacheSpec.QueryFields
	5,  // 2: goten.annotations.CacheSpec.query_reference_patterns:type_name -> goten.annotations.CacheSpec.QueryReferencePatterns
	9,  // 3: goten.annotations.IndicesSpec.composite:type_name -> goten.annotations.IndicesSpec.Composite
	8,  // 4: goten.annotations.IndicesSpec.single:type_name -> goten.annotations.IndicesSpec.SingleField
	6,  // 5: goten.annotations.IndicesSpec.Composite.sorting_groups:type_name -> goten.annotations.IndicesSpec.SortingGroup
	7,  // 6: goten.annotations.IndicesSpec.Composite.filters:type_name -> goten.annotations.IndicesSpec.Filter
	10, // 7: goten.annotations.cache:extendee -> google.protobuf.MessageOptions
	10, // 8: goten.annotations.indices:extendee -> google.protobuf.MessageOptions
	11, // 9: goten.annotations.tx:extendee -> google.protobuf.MethodOptions
	2,  // 10: goten.annotations.cache:type_name -> goten.annotations.CacheSpec
	3,  // 11: goten.annotations.indices:type_name -> goten.annotations.IndicesSpec
	1,  // 12: goten.annotations.tx:type_name -> goten.annotations.StoreHandleSpec
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	10, // [10:13] is the sub-list for extension type_name
	7,  // [7:10] is the sub-list for extension extendee
	0,  // [0:7] is the sub-list for field type_name
}

func init() { file_goten_annotations_store_proto_init() }
func file_goten_annotations_store_proto_init() {
	if File_goten_annotations_store_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_goten_annotations_store_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StoreHandleSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CacheSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IndicesSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CacheSpec_QueryFields); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CacheSpec_QueryReferencePatterns); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IndicesSpec_SortingGroup); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IndicesSpec_Filter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IndicesSpec_SingleField); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_goten_annotations_store_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IndicesSpec_Composite); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_goten_annotations_store_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   9,
			NumExtensions: 3,
			NumServices:   0,
		},
		GoTypes:           file_goten_annotations_store_proto_goTypes,
		DependencyIndexes: file_goten_annotations_store_proto_depIdxs,
		EnumInfos:         file_goten_annotations_store_proto_enumTypes,
		MessageInfos:      file_goten_annotations_store_proto_msgTypes,
		ExtensionInfos:    file_goten_annotations_store_proto_extTypes,
	}.Build()
	File_goten_annotations_store_proto = out.File
	file_goten_annotations_store_proto_rawDesc = nil
	file_goten_annotations_store_proto_goTypes = nil
	file_goten_annotations_store_proto_depIdxs = nil
}
